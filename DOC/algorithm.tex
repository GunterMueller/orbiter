\section{The classification algorithm}
\label{sec:algorithm}

How does one classify combinatorial objects?
From what we have learned in the previous section, the problem of classification requires us to compute orbits 
of certain groups acting on certain classes of functions as discussed in Section~\ref{sec:modeling}. 
The difficulty is that the set of functions may be very large, so that 
it may be infeasible to even look at every function. 
The existence of a group action on the set of functions may make this problem feasible in the first place. 
The set of functions may be very large but the number of orbits under the group may still be 
reasonably small. The question is if we can get hold of these orbits efficiently. 
To do so, we would like to avoid having to look at every function in the set $\frakF.$


\bigskip


The main idea in the classification algorithm 
is to break the problem into smaller steps, each of which can be handled 
with reasonable effort. 
To enable small steps, we use an inductive scheme. In each step, we 
take a smaller classification problem and lift it to a larger one.
To enable induction, we embed the combinatorial objects into a set which is equipped with an order relation.
We use order structures 
like lattices and partially ordered sets (posets, for short). 
We start by embedding the combinatorial 
structures of the given type into a lattice.
In order to enable induction, we require that the lattice has a rank function.
What is a rank function?
If $\frakL$ is a lattice, a rank function on $\frakL$ 
is the mapping 
$r: \frakL \rightarrow \bbZ_{\ge 0}$ such that $r(0) = 0$ and 
if $x <y$ and there is no $z$ such that $x < z < y$ then 
$r(y) = r(x) +1.$ 
The rank function as defined this way may or may not be well-defined. 
If it is, the we say that the lattice is ranked.
For instance, the power set $\frakP(X)$ of a fixed finite set $X$ (i.e., the set of all subsets of $X$) 
is ranked. The rank of a set is the size of the set.
Another example of a ranked lattice is the lattice $\frakL(V)$ of all subspaces of the finite dimensional 
vector space $V$. The rank of a subspace is given by the dimension.
The $i$-th layer in $\frakL$ is 
$$
\frakL_i = \{ x \in \frakL \mid r(x) = i \}.
$$

\bigskip

The next step is to consider group actions on lattices and posets.
A group $G$ is said to act on the lattice $\frakL$ if
$$
x < y \Rightarrow x^g < y^g
$$
for all $x,y \in \frakL$ and all $g \in G.$


\bigskip


Let $\cC$ be the combinatorial structures of a given type.
Let $\cC$ be embedded in a ranked lattice $\frakL$.
We require that there is a subset $\cP$ of 
$\frakL$ with the following properties:
\begin{enumerate}
\item 
$\cC \subseteq \cP.$
\item
If $y \in \cP$ and 
$x \in \frakL$ with $x < y$ then $x \in \cP$ also. 
\item
If $x \in \cP$ and $g \in G$ then $x^g \in \cP$ also.
\end{enumerate}
The subset $\cP$ of $\frakL$ carries an order structure induced from $\frakL,$ 
and hence $\cP$ is itself a poset. 
In fact, $\cP$ is a semilattice: 
with $x$ and $y$ in $\cP$, we also have $x \wedge y \in \cP$  
(but not necessarily $x \vee y \in \cP$).
We put $\cP_i = \frakL_i \cap \cP.$
Let $R =  \{ r(x) \mid x \in \cP \}$. Then $R$ is an interval of the form $[0,\ldots,t].$
The level $t$ is called the target level.
We introduce an indicator function for the poset $\cP$ inside $\frakL.$ 
Let $\chi: \frakL \rightarrow \{0,1\}$ be one if $x$ is in $\cP$ and zero otherwise.
The properties for $\cP$ translate into properties for $\chi$
\begin{enumerate}
\item
$\chi(x^g) = \chi(x)$ for all $x \in \cL$ and all $g \in G$, and
\item
For $x < y,$ we have $\chi(y) = 1$ implies $\chi(x) = 1.$ 
\end{enumerate}
A function $\chi$ satisfying these two requirements is called a {\em test-function}.



\bigskip

With this setup, we can now devise an inductive scheme to classify 
the combinatorial objects $\cC.$
The classification process computes the orbits of $G$ on $\cP$ by induction on the layers. 
This computation starts at the bottom layer $\cP_0$ and moves up 
from $\cP_i$ to $\cP_{i+1}$ for $i =0,\ldots,t-1.$ 
In each step, the orbits of $G$ on $\cP_i$ are classified.
Once $\cP_t$ is classified, algorithm terminates. 
The $G$-orbits on $\cC$ have been computed.

\bigskip

The set of $G$-orbits on the poset 
forms another partially ordered set. 
We say that  $x^G < y^G$ if there are elements 
$a,b$ with $a \in x^G$ and $b \in y^G$ and $a < b$ in the original poset.
The poset that we obtain in this way is called the {\em poset of $G$-orbits}. 


\bigskip




